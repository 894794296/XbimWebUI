export const worker = "(function(e, a) { for(var i in a) e[i] = a[i]; }(this, /******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId]) {\n/******/ 			return installedModules[moduleId].exports;\n/******/ 		}\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			i: moduleId,\n/******/ 			l: false,\n/******/ 			exports: {}\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.l = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// define getter function for harmony exports\n/******/ 	__webpack_require__.d = function(exports, name, getter) {\n/******/ 		if(!__webpack_require__.o(exports, name)) {\n/******/ 			Object.defineProperty(exports, name, {\n/******/ 				configurable: false,\n/******/ 				enumerable: true,\n/******/ 				get: getter\n/******/ 			});\n/******/ 		}\n/******/ 	};\n/******/\n/******/ 	// define __esModule on exports\n/******/ 	__webpack_require__.r = function(exports) {\n/******/ 		Object.defineProperty(exports, '__esModule', { value: true });\n/******/ 	};\n/******/\n/******/ 	// getDefaultExport function for compatibility with non-harmony modules\n/******/ 	__webpack_require__.n = function(module) {\n/******/ 		var getter = module && module.__esModule ?\n/******/ 			function getDefault() { return module['default']; } :\n/******/ 			function getModuleExports() { return module; };\n/******/ 		__webpack_require__.d(getter, 'a', getter);\n/******/ 		return getter;\n/******/ 	};\n/******/\n/******/ 	// Object.prototype.hasOwnProperty.call\n/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(__webpack_require__.s = \"./src/workers/geometry-loader.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/binary-reader.ts\":\n/*!******************************!*\\n  !*** ./src/binary-reader.ts ***!\n  \******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/**\\r\\n * Convenient class for binary reading. Arrays are read as new views on slices of the original data buffer,\\r\\n * individual values are read using little endian data view.\\r\\n */\\r\\nvar BinaryReader = /** @class */ (function () {\\r\\n    function BinaryReader() {\\r\\n        this._buffer = null;\\r\\n        this._view = null;\\r\\n        this._position = 0;\\r\\n    }\\r\\n    Object.defineProperty(BinaryReader.prototype, \\\"Position\\\", {\\r\\n        /**\\r\\n         * Current position\\r\\n         */\\r\\n        get: function () {\\r\\n            return this._position;\\r\\n        },\\r\\n        enumerable: true,\\r\\n        configurable: true\\r\\n    });\\r\\n    /**\\r\\n     * Gets reader for a sub array starting at current position.\\r\\n     * This enforces isolation of reading within certain data island.\\r\\n     *\\r\\n     * @param length Byte length of the data island\\r\\n     */\\r\\n    BinaryReader.prototype.getSubReader = function (length) {\\r\\n        var reader = new BinaryReader();\\r\\n        //get slice of the data\\r\\n        var data = this._buffer.slice(this._position, this._position + length);\\r\\n        //load is synchronous with ArrayBuffer argument\\r\\n        reader.load(data, null);\\r\\n        //move position after the data island\\r\\n        this._position += length;\\r\\n        //return new reader\\r\\n        return reader;\\r\\n    };\\r\\n    /**\\r\\n     * Pass url string, blob, file of byte array to this function to initialize the reader. Only array buffer takes imidiate effect.\\r\\n     * Othe sources are loaded asynchronously and you need to use 'onloaded' delegate to use the reader only after it is initialized woth the data.\\r\\n     * @param source URL string of the file or BLOB or File or ArrayBuffer object\\r\\n     * @param headers http headers to be used to fetch data\\r\\n     */\\r\\n    BinaryReader.prototype.load = function (source, headers) {\\r\\n        this._position = 0;\\r\\n        var self = this;\\r\\n        if (typeof (source) == 'undefined' || source == null)\\r\\n            throw 'Source must be defined';\\r\\n        if (typeof (source) == 'string') {\\r\\n            var xhr_1 = new XMLHttpRequest();\\r\\n            xhr_1.open(\\\"GET\\\", location.origin + source, true);\\r\\n            xhr_1.onreadystatechange = function () {\\r\\n                if (xhr_1.readyState == 4 && xhr_1.status == 200) {\\r\\n                    var fReader = new FileReader();\\r\\n                    fReader.onloadend = function () {\\r\\n                        if (fReader.result) {\\r\\n                            //set data buffer for next processing\\r\\n                            self._buffer = fReader.result;\\r\\n                            self._view = new DataView(self._buffer);\\r\\n                            //do predefined processing of the data\\r\\n                            if (self.onloaded) {\\r\\n                                self.onloaded(self);\\r\\n                            }\\r\\n                        }\\r\\n                    };\\r\\n                    fReader.readAsArrayBuffer(xhr_1.response);\\r\\n                }\\r\\n                //throw exception as a warning\\r\\n                if (xhr_1.readyState == 4 && xhr_1.status != 200) {\\r\\n                    var msg = 'Failed to fetch binary data from server. Server code: ' +\\r\\n                        xhr_1.status +\\r\\n                        '. This might be due to CORS policy of your browser if you run this as a local file.';\\r\\n                    if (self.onerror)\\r\\n                        self.onerror(msg);\\r\\n                    throw msg;\\r\\n                }\\r\\n            };\\r\\n            xhr_1.responseType = 'blob';\\r\\n            if (typeof headers !== 'undefined') {\\r\\n                Object.keys(headers).forEach(function (header) {\\r\\n                    var value = headers[header];\\r\\n                    xhr_1.setRequestHeader(header, value);\\r\\n                });\\r\\n            }\\r\\n            xhr_1.send();\\r\\n        }\\r\\n        else if (source instanceof Blob || source instanceof File) {\\r\\n            var fReader = new FileReader();\\r\\n            fReader.onloadend = function () {\\r\\n                if (fReader.result) {\\r\\n                    //set data buffer for next processing\\r\\n                    self._buffer = fReader.result;\\r\\n                    self._view = new DataView(self._buffer);\\r\\n                    //do predefined processing of the data\\r\\n                    if (self.onloaded) {\\r\\n                        self.onloaded(self);\\r\\n                    }\\r\\n                }\\r\\n            };\\r\\n            fReader.readAsArrayBuffer(source);\\r\\n        }\\r\\n        else if (source instanceof ArrayBuffer) {\\r\\n            this._buffer = source;\\r\\n            this._view = new DataView(self._buffer);\\r\\n            if (self.onloaded) {\\r\\n                self.onloaded(self);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n    BinaryReader.prototype.seek = function (position) {\\r\\n        if (position < 0 || position > this._buffer.byteLength)\\r\\n            throw \\\"Position out of range.\\\";\\r\\n        this._position = position;\\r\\n    };\\r\\n    BinaryReader.prototype.isEOF = function () {\\r\\n        if (this._position == null)\\r\\n            throw \\\"Position is not defined\\\";\\r\\n        return this._position == this._buffer.byteLength;\\r\\n    };\\r\\n    BinaryReader.prototype.readArray = function (unitSize, count, ctor) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var length = unitSize * count;\\r\\n        var offset = this._position;\\r\\n        this._position += length;\\r\\n        var result;\\r\\n        return count === 1\\r\\n            ? new ctor(this._buffer.slice(offset, offset + length))[0]\\r\\n            : new ctor(this._buffer.slice(offset, offset + length));\\r\\n    };\\r\\n    BinaryReader.prototype.move = function (size) {\\r\\n        var offset = this._position;\\r\\n        this._position += size;\\r\\n        return offset;\\r\\n    };\\r\\n    BinaryReader.prototype.readByte = function () {\\r\\n        return this.readUint8();\\r\\n    };\\r\\n    BinaryReader.prototype.readByteArray = function (count) {\\r\\n        return this.readUint8Array(count);\\r\\n    };\\r\\n    BinaryReader.prototype.readUint8 = function () {\\r\\n        var offset = this.move(1);\\r\\n        return this._view.getUint8(offset);\\r\\n    };\\r\\n    BinaryReader.prototype.readUint8Array = function (count) {\\r\\n        return this.readArray(1, count, Uint8Array);\\r\\n    };\\r\\n    BinaryReader.prototype.readInt16 = function () {\\r\\n        var offset = this.move(2);\\r\\n        return this._view.getInt16(offset, true);\\r\\n    };\\r\\n    BinaryReader.prototype.readInt16Array = function (count) {\\r\\n        return this.readArray(2, count, Int16Array);\\r\\n    };\\r\\n    BinaryReader.prototype.readUInt16 = function () {\\r\\n        var offset = this.move(2);\\r\\n        return this._view.getUint16(offset, true);\\r\\n    };\\r\\n    BinaryReader.prototype.readUint16Array = function (count) {\\r\\n        return this.readArray(2, count, Uint16Array);\\r\\n    };\\r\\n    BinaryReader.prototype.readInt32 = function () {\\r\\n        var offset = this.move(4);\\r\\n        return this._view.getInt32(offset, true);\\r\\n    };\\r\\n    BinaryReader.prototype.readInt32Array = function (count) {\\r\\n        return this.readArray(4, count, Int32Array);\\r\\n    };\\r\\n    BinaryReader.prototype.readUint32 = function () {\\r\\n        var offset = this.move(4);\\r\\n        return this._view.getUint32(offset, true);\\r\\n    };\\r\\n    BinaryReader.prototype.readUint32Array = function (count) {\\r\\n        return this.readArray(4, count, Uint32Array);\\r\\n    };\\r\\n    BinaryReader.prototype.readFloat32 = function () {\\r\\n        var offset = this.move(4);\\r\\n        return this._view.getFloat32(offset, true);\\r\\n    };\\r\\n    BinaryReader.prototype.readFloat32Array = function (count) {\\r\\n        return this.readArray(4, count, Float32Array);\\r\\n    };\\r\\n    BinaryReader.prototype.readFloat64 = function () {\\r\\n        var offset = this.move(8);\\r\\n        return this._view.getFloat64(offset, true);\\r\\n    };\\r\\n    BinaryReader.prototype.readFloat64Array = function (count) {\\r\\n        return this.readArray(8, count, Float64Array);\\r\\n    };\\r\\n    //functions for a higher objects like points, colours and matrices\\r\\n    BinaryReader.prototype.readChar = function (count) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var bytes = this.readByteArray(count);\\r\\n        var result = new Array(count);\\r\\n        for (var i in bytes) {\\r\\n            result[i] = String.fromCharCode(bytes[i]);\\r\\n        }\\r\\n        return count === 1 ? result[0] : result;\\r\\n    };\\r\\n    BinaryReader.prototype.readPoint = function (count) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var coords = this.readFloat32Array(count * 3);\\r\\n        var result = new Array(count);\\r\\n        for (var i = 0; i < count; i++) {\\r\\n            var offset = i * 3 * 4;\\r\\n            //only create new view on the buffer so that no new memory is allocated\\r\\n            var point = new Float32Array(coords.buffer, offset, 3);\\r\\n            result[i] = point;\\r\\n        }\\r\\n        return count === 1 ? result[0] : result;\\r\\n    };\\r\\n    BinaryReader.prototype.readRgba = function (count) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var values = this.readByteArray(count * 4);\\r\\n        var result = new Array(count);\\r\\n        for (var i = 0; i < count; i++) {\\r\\n            var offset = i * 4;\\r\\n            var colour = new Uint8Array(values.buffer, offset, 4);\\r\\n            result[i] = colour;\\r\\n        }\\r\\n        return count === 1 ? result[0] : result;\\r\\n    };\\r\\n    BinaryReader.prototype.readPackedNormal = function (count) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var values = this.readUint8Array(count * 2);\\r\\n        var result = new Array(count);\\r\\n        for (var i = 0; i < count; i++) {\\r\\n            var uv = new Uint8Array(values.buffer, i * 2, 2);\\r\\n            result[i] = uv;\\r\\n        }\\r\\n        return count === 1 ? result[0] : result;\\r\\n    };\\r\\n    BinaryReader.prototype.readMatrix4x4 = function (count) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var values = this.readFloat32Array(count * 16);\\r\\n        var result = new Array(count);\\r\\n        for (var i = 0; i < count; i++) {\\r\\n            var offset = i * 16 * 4;\\r\\n            var matrix = new Float32Array(values.buffer, offset, 16);\\r\\n            result[i] = matrix;\\r\\n        }\\r\\n        return count === 1 ? result[0] : result;\\r\\n    };\\r\\n    BinaryReader.prototype.readMatrix4x4_64 = function (count) {\\r\\n        if (count == null)\\r\\n            count = 1;\\r\\n        var values = this.readFloat64Array(count * 16);\\r\\n        var result = new Array(count);\\r\\n        for (var i = 0; i < count; i++) {\\r\\n            var offset = i * 16 * 8;\\r\\n            var matrix = new Float64Array(values.buffer, offset, 16);\\r\\n            result[i] = matrix;\\r\\n        }\\r\\n        return count === 1 ? result[0] : result;\\r\\n    };\\r\\n    /**\\r\\n     * Reads slice of data from the underlying array buffer\\r\\n     * @param length Length of requested data. Start is at current position\\r\\n     */\\r\\n    BinaryReader.prototype.readData = function (length) {\\r\\n        var offset = this.move(length);\\r\\n        return this._buffer.slice(offset, offset + length);\\r\\n    };\\r\\n    return BinaryReader;\\r\\n}());\\r\\nexports.BinaryReader = BinaryReader;\\r\\n\\n\\n//# sourceURL=webpack:///./src/binary-reader.ts?\");\n\n/***/ }),\n\n/***/ \"./src/model-geometry.ts\":\n/*!*******************************!*\\n  !*** ./src/model-geometry.ts ***!\n  \*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar binary_reader_1 = __webpack_require__(/*! ./binary-reader */ \\\"./src/binary-reader.ts\\\");\\r\\nvar triangulated_shape_1 = __webpack_require__(/*! ./triangulated-shape */ \\\"./src/triangulated-shape.ts\\\");\\r\\nvar state_1 = __webpack_require__(/*! ./state */ \\\"./src/state.ts\\\");\\r\\nvar product_type_1 = __webpack_require__(/*! ./product-type */ \\\"./src/product-type.ts\\\");\\r\\nvar ModelGeometry = /** @class */ (function () {\\r\\n    function ModelGeometry() {\\r\\n        this.meter = 1000;\\r\\n        //this will be used to change appearance of the objects\\r\\n        //map objects have a format: \\r\\n        //map = {\\r\\n        //\tproductID: int,\\r\\n        //\ttype: int,\\r\\n        //\tbBox: Float32Array(6),\\r\\n        //\tspans: [Int32Array([int, int]),Int32Array([int, int]), ...] //spanning indexes defining shapes of product and it's state\\r\\n        //};\\r\\n        this._iVertex = 0;\\r\\n        this._iIndexForward = 0;\\r\\n        this._iIndexBackward = 0;\\r\\n        this._iTransform = 0;\\r\\n        this._iMatrix = 0;\\r\\n        this.productMaps = {};\\r\\n        this._styleMap = new StyleMap();\\r\\n    }\\r\\n    ModelGeometry.prototype.parse = function (binReader) {\\r\\n        this._reader = binReader;\\r\\n        var br = binReader;\\r\\n        var magicNumber = br.readInt32();\\r\\n        if (magicNumber != 94132117)\\r\\n            throw 'Magic number mismatch.';\\r\\n        var version = br.readByte();\\r\\n        var numShapes = br.readInt32();\\r\\n        var numVertices = br.readInt32();\\r\\n        var numTriangles = br.readInt32();\\r\\n        var numMatrices = br.readInt32();\\r\\n        ;\\r\\n        var numProducts = br.readInt32();\\r\\n        ;\\r\\n        var numStyles = br.readInt32();\\r\\n        ;\\r\\n        this.meter = br.readFloat32();\\r\\n        ;\\r\\n        var numRegions = br.readInt16();\\r\\n        //create target buffers of correct sizes (avoid reallocation of memory, work with native typed arrays)\\r\\n        this.vertices = new Float32Array(this.square(4, numVertices * 3));\\r\\n        this.normals = new Uint8Array(numTriangles * 6);\\r\\n        this.indices = new Float32Array(numTriangles * 3);\\r\\n        this.styleIndices = new Uint16Array(numTriangles * 3);\\r\\n        this.styles = new Uint8Array(this.square(1, (numStyles + 1) * 4)); //+1 is for a default style\\r\\n        this.products = new Float32Array(numTriangles * 3);\\r\\n        this.states = new Uint8Array(numTriangles * 3 * 2); //place for state and restyling\\r\\n        this.transformations = new Float32Array(numTriangles * 3);\\r\\n        this.matrices = new Float32Array(this.square(4, numMatrices * 16));\\r\\n        this.productMaps = {};\\r\\n        this.regions = new Array(numRegions);\\r\\n        //initial values for indices for iterations over data\\r\\n        this._iVertex = 0;\\r\\n        this._iIndexForward = 0;\\r\\n        this._iIndexBackward = numTriangles * 3;\\r\\n        this._iTransform = 0;\\r\\n        this._iMatrix = 0;\\r\\n        for (var i = 0; i < numRegions; i++) {\\r\\n            var region = new Region();\\r\\n            region.population = br.readInt32();\\r\\n            region.centre = br.readFloat32Array(3);\\r\\n            region.bbox = br.readFloat32Array(6);\\r\\n            this.regions[i] = region;\\r\\n        }\\r\\n        var iStyle = 0;\\r\\n        for (iStyle; iStyle < numStyles; iStyle++) {\\r\\n            var styleId = br.readInt32();\\r\\n            var R = br.readFloat32() * 255;\\r\\n            var G = br.readFloat32() * 255;\\r\\n            var B = br.readFloat32() * 255;\\r\\n            var A = br.readFloat32() * 255;\\r\\n            this.styles.set([R, G, B, A], iStyle * 4);\\r\\n            this._styleMap.Add({ id: styleId, index: iStyle, transparent: A < 254 });\\r\\n        }\\r\\n        this.styles.set([255, 255, 255, 255], iStyle * 4);\\r\\n        var defaultStyle = { id: -1, index: iStyle, transparent: false };\\r\\n        this._styleMap.Add(defaultStyle);\\r\\n        for (var i = 0; i < numProducts; i++) {\\r\\n            var productLabel = br.readInt32();\\r\\n            var prodType = br.readInt16();\\r\\n            var bBox = br.readFloat32Array(6);\\r\\n            var map = {\\r\\n                productID: productLabel,\\r\\n                type: prodType,\\r\\n                bBox: bBox,\\r\\n                spans: []\\r\\n            };\\r\\n            this.productMaps[productLabel] = map;\\r\\n        }\\r\\n        //version 3 puts geometry in regions properly so it is possible to use this information for rendering\\r\\n        if (version >= 3) {\\r\\n            for (var r = 0; r < numRegions; r++) {\\r\\n                var region = this.regions[r];\\r\\n                var geomCount = br.readInt32();\\r\\n                for (var g = 0; g < geomCount; g++) {\\r\\n                    //read shape information\\r\\n                    var shapes = this.readShape(version);\\r\\n                    //read geometry\\r\\n                    var geomLength = br.readInt32();\\r\\n                    //read geometry data (make sure we don't overflow - use isolated subreader)\\r\\n                    var gbr = br.getSubReader(geomLength);\\r\\n                    var geometry = new triangulated_shape_1.TriangulatedShape();\\r\\n                    geometry.parse(gbr);\\r\\n                    //make sure that geometry is complete\\r\\n                    if (!gbr.isEOF())\\r\\n                        throw new Error(\\\"Incomplete reading of geometry for shape instance \\\" + shapes[0].iLabel);\\r\\n                    //add data to arrays prepared for GPU\\r\\n                    this.feedDataArrays(shapes, geometry);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            //older versions use less safety and just iterate over in a single loop\\r\\n            for (var iShape = 0; iShape < numShapes; iShape++) {\\r\\n                //reed shape representations\\r\\n                var shapes_1 = this.readShape(version);\\r\\n                //read shape geometry\\r\\n                var geometry = new triangulated_shape_1.TriangulatedShape();\\r\\n                geometry.parse(br);\\r\\n                //feed data arays\\r\\n                this.feedDataArrays(shapes_1, geometry);\\r\\n            }\\r\\n        }\\r\\n        //binary reader should be at the end by now\\r\\n        if (!br.isEOF()) {\\r\\n            throw new Error('Binary reader is not at the end of the file.');\\r\\n        }\\r\\n        //set value of transparent index divider for two phase rendering (simplified ordering)\\r\\n        this.transparentIndex = this._iIndexForward;\\r\\n    };\\r\\n    /**\\r\\n     * Get size of arrays to be square (usable for texture data)\\r\\n     * @param arity\\r\\n     * @param count\\r\\n     */\\r\\n    ModelGeometry.prototype.square = function (arity, count) {\\r\\n        if (typeof (arity) == 'undefined' || typeof (count) == 'undefined') {\\r\\n            throw new Error('Wrong arguments for \\\"square\\\" function.');\\r\\n        }\\r\\n        if (count == 0)\\r\\n            return 0;\\r\\n        var byteLength = count * arity;\\r\\n        var imgSide = Math.ceil(Math.sqrt(byteLength / 4));\\r\\n        //clamp to parity\\r\\n        while ((imgSide * 4) % arity != 0) {\\r\\n            imgSide++;\\r\\n        }\\r\\n        var result = imgSide * imgSide * 4 / arity;\\r\\n        return result;\\r\\n    };\\r\\n    ModelGeometry.prototype.feedDataArrays = function (shapes, geometry) {\\r\\n        var _this = this;\\r\\n        //copy shape data into inner array and set to null so it can be garbage collected\\r\\n        shapes.forEach(function (shape) {\\r\\n            var iIndex = 0;\\r\\n            //set iIndex according to transparency either from beginning or at the end\\r\\n            if (shape.transparent) {\\r\\n                iIndex = _this._iIndexBackward - geometry.indices.length;\\r\\n            }\\r\\n            else {\\r\\n                iIndex = _this._iIndexForward;\\r\\n            }\\r\\n            var begin = iIndex;\\r\\n            var map = _this.productMaps[shape.pLabel];\\r\\n            if (typeof (map) === \\\"undefined\\\") {\\r\\n                //throw \\\"Product hasn't been defined before.\\\";\\r\\n                map = {\\r\\n                    productID: 0,\\r\\n                    type: product_type_1.ProductType.IFCOPENINGELEMENT,\\r\\n                    bBox: new Float32Array(6),\\r\\n                    spans: []\\r\\n                };\\r\\n                _this.productMaps[shape.pLabel] = map;\\r\\n            }\\r\\n            _this.normals.set(geometry.normals, iIndex * 2);\\r\\n            //switch spaces and openings off by default \\r\\n            var state = map.type == product_type_1.ProductType.IFCSPACE || map.type == product_type_1.ProductType.IFCOPENINGELEMENT\\r\\n                ? state_1.State.HIDDEN\\r\\n                : 0xFF; //0xFF is for the default state\\r\\n            //fix indices to right absolute position. It is relative to the shape.\\r\\n            for (var i = 0; i < geometry.indices.length; i++) {\\r\\n                _this.indices[iIndex] = geometry.indices[i] + _this._iVertex / 3;\\r\\n                _this.products[iIndex] = shape.pLabel;\\r\\n                _this.styleIndices[iIndex] = shape.style;\\r\\n                _this.transformations[iIndex] = shape.transform; //shape.pLabel == 33698 || shape.pLabel == 33815 ? -1 : shape.transform;\\r\\n                _this.states[2 * iIndex] = state; //set state\\r\\n                _this.states[2 * iIndex + 1] = 0xFF; //default style\\r\\n                iIndex++;\\r\\n            }\\r\\n            var end = iIndex;\\r\\n            map.spans.push(new Int32Array([begin, end]));\\r\\n            if (shape.transparent)\\r\\n                _this._iIndexBackward -= geometry.indices.length;\\r\\n            else\\r\\n                _this._iIndexForward += geometry.indices.length;\\r\\n        }, this);\\r\\n        //copy geometry and keep track of amount so that we can fix indices to right position\\r\\n        //this must be the last step to have correct iVertex number above\\r\\n        this.vertices.set(geometry.vertices, this._iVertex);\\r\\n        this._iVertex += geometry.vertices.length;\\r\\n    };\\r\\n    ModelGeometry.prototype.readShape = function (version) {\\r\\n        var br = this._reader;\\r\\n        var repetition = br.readInt32();\\r\\n        var shapeList = new Array();\\r\\n        for (var iProduct = 0; iProduct < repetition; iProduct++) {\\r\\n            var prodLabel = br.readInt32();\\r\\n            var instanceTypeId = br.readInt16();\\r\\n            var instanceLabel = br.readInt32();\\r\\n            var styleId = br.readInt32();\\r\\n            var transformation = null;\\r\\n            if (repetition > 1) {\\r\\n                //version 1 had lower precission of transformation matrices\\r\\n                transformation = version === 1 ? br.readFloat32Array(16) : br.readFloat64Array(16);\\r\\n                this.matrices.set(transformation, this._iMatrix);\\r\\n                this._iMatrix += 16;\\r\\n            }\\r\\n            var styleItem = this._styleMap.GetStyle(styleId);\\r\\n            if (styleItem === null)\\r\\n                styleItem = this._styleMap.GetStyle(-1); //default style\\r\\n            shapeList.push({\\r\\n                pLabel: prodLabel,\\r\\n                iLabel: instanceLabel,\\r\\n                style: styleItem.index,\\r\\n                transparent: styleItem.transparent,\\r\\n                transform: transformation != null ? this._iTransform++ : -1\\r\\n            });\\r\\n        }\\r\\n        return shapeList;\\r\\n    };\\r\\n    //Source has to be either URL of wexBIM file or Blob representing wexBIM file\\r\\n    ModelGeometry.prototype.load = function (source, headers) {\\r\\n        //binary reading\\r\\n        var br = new binary_reader_1.BinaryReader();\\r\\n        var self = this;\\r\\n        br.onloaded = function () {\\r\\n            self.parse(br);\\r\\n            if (self.onloaded) {\\r\\n                self.onloaded(this);\\r\\n            }\\r\\n        };\\r\\n        br.onerror = function (msg) {\\r\\n            if (self.onerror)\\r\\n                self.onerror(msg);\\r\\n        };\\r\\n        br.load(source, headers);\\r\\n    };\\r\\n    return ModelGeometry;\\r\\n}());\\r\\nexports.ModelGeometry = ModelGeometry;\\r\\nvar ProductMap = /** @class */ (function () {\\r\\n    function ProductMap() {\\r\\n    }\\r\\n    return ProductMap;\\r\\n}());\\r\\nexports.ProductMap = ProductMap;\\r\\nvar Region = /** @class */ (function () {\\r\\n    function Region(region) {\\r\\n        this.population = -1;\\r\\n        this.centre = null;\\r\\n        this.bbox = null;\\r\\n        if (region) {\\r\\n            this.population = region.population;\\r\\n            this.centre = new Float32Array(region.centre);\\r\\n            this.bbox = new Float32Array(region.bbox);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Returns clone of this region\\r\\n     */\\r\\n    Region.prototype.clone = function () {\\r\\n        var clone = new Region();\\r\\n        clone.population = this.population;\\r\\n        clone.centre = new Float32Array(this.centre);\\r\\n        clone.bbox = new Float32Array(this.bbox);\\r\\n        return clone;\\r\\n    };\\r\\n    /**\\r\\n     * Returns new region which is a merge of this region and the argument\\r\\n     * @param region region to be merged\\r\\n     */\\r\\n    Region.prototype.merge = function (region) {\\r\\n        //if this is a new empty region, return clone of the argument\\r\\n        if (this.population === -1 && this.centre === null && this.bbox === null)\\r\\n            return new Region(region);\\r\\n        var out = new Region();\\r\\n        out.population = this.population + region.population;\\r\\n        var x = Math.min(this.bbox[0], region.bbox[0]);\\r\\n        var y = Math.min(this.bbox[1], region.bbox[1]);\\r\\n        var z = Math.min(this.bbox[2], region.bbox[2]);\\r\\n        var x2 = Math.max(this.bbox[0] + this.bbox[3], region.bbox[0] + region.bbox[3]);\\r\\n        var y2 = Math.max(this.bbox[1] + this.bbox[4], region.bbox[1] + region.bbox[4]);\\r\\n        var z2 = Math.max(this.bbox[2] + this.bbox[5], region.bbox[2] + region.bbox[5]);\\r\\n        var sx = x2 - x;\\r\\n        var sy = y2 - y;\\r\\n        var sz = z2 - z;\\r\\n        var cx = (x + x2) / 2.0;\\r\\n        var cy = (y + y2) / 2.0;\\r\\n        var cz = (z + z2) / 2.0;\\r\\n        out.bbox = new Float32Array([x, y, z, sx, sy, sz]);\\r\\n        out.centre = new Float32Array([cx, cy, cz]);\\r\\n        return out;\\r\\n    };\\r\\n    return Region;\\r\\n}());\\r\\nexports.Region = Region;\\r\\nvar StyleMap = /** @class */ (function () {\\r\\n    function StyleMap() {\\r\\n        this._internal = {};\\r\\n    }\\r\\n    StyleMap.prototype.Add = function (record) {\\r\\n        this._internal[record.id] = record;\\r\\n    };\\r\\n    StyleMap.prototype.GetStyle = function (id) {\\r\\n        var item = this._internal[id];\\r\\n        if (item)\\r\\n            return item;\\r\\n        return null;\\r\\n    };\\r\\n    return StyleMap;\\r\\n}());\\r\\nvar StyleRecord = /** @class */ (function () {\\r\\n    function StyleRecord() {\\r\\n    }\\r\\n    return StyleRecord;\\r\\n}());\\r\\nvar ShapeRecord = /** @class */ (function () {\\r\\n    function ShapeRecord() {\\r\\n    }\\r\\n    return ShapeRecord;\\r\\n}());\\r\\n\\n\\n//# sourceURL=webpack:///./src/model-geometry.ts?\");\n\n/***/ }),\n\n/***/ \"./src/product-type.ts\":\n/*!*****************************!*\\n  !*** ./src/product-type.ts ***!\n  \*****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/**\\r\\n * Enumeration of product types.\\r\\n * @readonly\\r\\n * @enum {number}\\r\\n */\\r\\nvar ProductType;\\r\\n(function (ProductType) {\\r\\n    ProductType[ProductType[\\\"IFCPRODUCT\\\"] = 20] = \\\"IFCPRODUCT\\\";\\r\\n    ProductType[ProductType[\\\"IFCELEMENT\\\"] = 19] = \\\"IFCELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCBUILDINGELEMENT\\\"] = 26] = \\\"IFCBUILDINGELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCFOOTING\\\"] = 120] = \\\"IFCFOOTING\\\";\\r\\n    ProductType[ProductType[\\\"IFCPILE\\\"] = 572] = \\\"IFCPILE\\\";\\r\\n    ProductType[ProductType[\\\"IFCBEAM\\\"] = 171] = \\\"IFCBEAM\\\";\\r\\n    ProductType[ProductType[\\\"IFCBEAMSTANDARDCASE\\\"] = 1104] = \\\"IFCBEAMSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCBUILDINGELEMENTPROXY\\\"] = 560] = \\\"IFCBUILDINGELEMENTPROXY\\\";\\r\\n    ProductType[ProductType[\\\"IFCCHIMNEY\\\"] = 1120] = \\\"IFCCHIMNEY\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOLUMN\\\"] = 383] = \\\"IFCCOLUMN\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOLUMNSTANDARDCASE\\\"] = 1126] = \\\"IFCCOLUMNSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOVERING\\\"] = 382] = \\\"IFCCOVERING\\\";\\r\\n    ProductType[ProductType[\\\"IFCCURTAINWALL\\\"] = 456] = \\\"IFCCURTAINWALL\\\";\\r\\n    ProductType[ProductType[\\\"IFCDOOR\\\"] = 213] = \\\"IFCDOOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCDOORSTANDARDCASE\\\"] = 1151] = \\\"IFCDOORSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCMEMBER\\\"] = 310] = \\\"IFCMEMBER\\\";\\r\\n    ProductType[ProductType[\\\"IFCMEMBERSTANDARDCASE\\\"] = 1214] = \\\"IFCMEMBERSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCPLATE\\\"] = 351] = \\\"IFCPLATE\\\";\\r\\n    ProductType[ProductType[\\\"IFCPLATESTANDARDCASE\\\"] = 1224] = \\\"IFCPLATESTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCRAILING\\\"] = 350] = \\\"IFCRAILING\\\";\\r\\n    ProductType[ProductType[\\\"IFCRAMP\\\"] = 414] = \\\"IFCRAMP\\\";\\r\\n    ProductType[ProductType[\\\"IFCRAMPFLIGHT\\\"] = 348] = \\\"IFCRAMPFLIGHT\\\";\\r\\n    ProductType[ProductType[\\\"IFCROOF\\\"] = 347] = \\\"IFCROOF\\\";\\r\\n    ProductType[ProductType[\\\"IFCSHADINGDEVICE\\\"] = 1265] = \\\"IFCSHADINGDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSLAB\\\"] = 99] = \\\"IFCSLAB\\\";\\r\\n    ProductType[ProductType[\\\"IFCSLABELEMENTEDCASE\\\"] = 1268] = \\\"IFCSLABELEMENTEDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSLABSTANDARDCASE\\\"] = 1269] = \\\"IFCSLABSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTAIR\\\"] = 346] = \\\"IFCSTAIR\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTAIRFLIGHT\\\"] = 25] = \\\"IFCSTAIRFLIGHT\\\";\\r\\n    ProductType[ProductType[\\\"IFCWALL\\\"] = 452] = \\\"IFCWALL\\\";\\r\\n    ProductType[ProductType[\\\"IFCWALLELEMENTEDCASE\\\"] = 1314] = \\\"IFCWALLELEMENTEDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCWALLSTANDARDCASE\\\"] = 453] = \\\"IFCWALLSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCWINDOW\\\"] = 667] = \\\"IFCWINDOW\\\";\\r\\n    ProductType[ProductType[\\\"IFCWINDOWSTANDARDCASE\\\"] = 1316] = \\\"IFCWINDOWSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCELEMENTCOMPONENT\\\"] = 424] = \\\"IFCELEMENTCOMPONENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCREINFORCINGELEMENT\\\"] = 262] = \\\"IFCREINFORCINGELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCREINFORCINGBAR\\\"] = 571] = \\\"IFCREINFORCINGBAR\\\";\\r\\n    ProductType[ProductType[\\\"IFCREINFORCINGMESH\\\"] = 531] = \\\"IFCREINFORCINGMESH\\\";\\r\\n    ProductType[ProductType[\\\"IFCTENDON\\\"] = 261] = \\\"IFCTENDON\\\";\\r\\n    ProductType[ProductType[\\\"IFCTENDONANCHOR\\\"] = 675] = \\\"IFCTENDONANCHOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCBUILDINGELEMENTPART\\\"] = 220] = \\\"IFCBUILDINGELEMENTPART\\\";\\r\\n    ProductType[ProductType[\\\"IFCDISCRETEACCESSORY\\\"] = 423] = \\\"IFCDISCRETEACCESSORY\\\";\\r\\n    ProductType[ProductType[\\\"IFCFASTENER\\\"] = 535] = \\\"IFCFASTENER\\\";\\r\\n    ProductType[ProductType[\\\"IFCMECHANICALFASTENER\\\"] = 536] = \\\"IFCMECHANICALFASTENER\\\";\\r\\n    ProductType[ProductType[\\\"IFCVIBRATIONISOLATOR\\\"] = 1312] = \\\"IFCVIBRATIONISOLATOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCFEATUREELEMENT\\\"] = 386] = \\\"IFCFEATUREELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCSURFACEFEATURE\\\"] = 1287] = \\\"IFCSURFACEFEATURE\\\";\\r\\n    ProductType[ProductType[\\\"IFCFEATUREELEMENTSUBTRACTION\\\"] = 499] = \\\"IFCFEATUREELEMENTSUBTRACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCVOIDINGFEATURE\\\"] = 1313] = \\\"IFCVOIDINGFEATURE\\\";\\r\\n    ProductType[ProductType[\\\"IFCOPENINGELEMENT\\\"] = 498] = \\\"IFCOPENINGELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCOPENINGSTANDARDCASE\\\"] = 1217] = \\\"IFCOPENINGSTANDARDCASE\\\";\\r\\n    ProductType[ProductType[\\\"IFCFEATUREELEMENTADDITION\\\"] = 385] = \\\"IFCFEATUREELEMENTADDITION\\\";\\r\\n    ProductType[ProductType[\\\"IFCPROJECTIONELEMENT\\\"] = 384] = \\\"IFCPROJECTIONELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCFURNISHINGELEMENT\\\"] = 253] = \\\"IFCFURNISHINGELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCFURNITURE\\\"] = 1184] = \\\"IFCFURNITURE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSYSTEMFURNITUREELEMENT\\\"] = 1291] = \\\"IFCSYSTEMFURNITUREELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCDISTRIBUTIONELEMENT\\\"] = 44] = \\\"IFCDISTRIBUTIONELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCDISTRIBUTIONFLOWELEMENT\\\"] = 45] = \\\"IFCDISTRIBUTIONFLOWELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCDISTRIBUTIONCHAMBERELEMENT\\\"] = 180] = \\\"IFCDISTRIBUTIONCHAMBERELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCENERGYCONVERSIONDEVICE\\\"] = 175] = \\\"IFCENERGYCONVERSIONDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCAIRTOAIRHEATRECOVERY\\\"] = 1097] = \\\"IFCAIRTOAIRHEATRECOVERY\\\";\\r\\n    ProductType[ProductType[\\\"IFCBOILER\\\"] = 1105] = \\\"IFCBOILER\\\";\\r\\n    ProductType[ProductType[\\\"IFCBURNER\\\"] = 1109] = \\\"IFCBURNER\\\";\\r\\n    ProductType[ProductType[\\\"IFCCHILLER\\\"] = 1119] = \\\"IFCCHILLER\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOIL\\\"] = 1124] = \\\"IFCCOIL\\\";\\r\\n    ProductType[ProductType[\\\"IFCCONDENSER\\\"] = 1132] = \\\"IFCCONDENSER\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOOLEDBEAM\\\"] = 1141] = \\\"IFCCOOLEDBEAM\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOOLINGTOWER\\\"] = 1142] = \\\"IFCCOOLINGTOWER\\\";\\r\\n    ProductType[ProductType[\\\"IFCENGINE\\\"] = 1164] = \\\"IFCENGINE\\\";\\r\\n    ProductType[ProductType[\\\"IFCEVAPORATIVECOOLER\\\"] = 1166] = \\\"IFCEVAPORATIVECOOLER\\\";\\r\\n    ProductType[ProductType[\\\"IFCEVAPORATOR\\\"] = 1167] = \\\"IFCEVAPORATOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCHEATEXCHANGER\\\"] = 1187] = \\\"IFCHEATEXCHANGER\\\";\\r\\n    ProductType[ProductType[\\\"IFCHUMIDIFIER\\\"] = 1188] = \\\"IFCHUMIDIFIER\\\";\\r\\n    ProductType[ProductType[\\\"IFCTUBEBUNDLE\\\"] = 1305] = \\\"IFCTUBEBUNDLE\\\";\\r\\n    ProductType[ProductType[\\\"IFCUNITARYEQUIPMENT\\\"] = 1310] = \\\"IFCUNITARYEQUIPMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCELECTRICGENERATOR\\\"] = 1160] = \\\"IFCELECTRICGENERATOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCELECTRICMOTOR\\\"] = 1161] = \\\"IFCELECTRICMOTOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCMOTORCONNECTION\\\"] = 1216] = \\\"IFCMOTORCONNECTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSOLARDEVICE\\\"] = 1270] = \\\"IFCSOLARDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCTRANSFORMER\\\"] = 1303] = \\\"IFCTRANSFORMER\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWCONTROLLER\\\"] = 121] = \\\"IFCFLOWCONTROLLER\\\";\\r\\n    ProductType[ProductType[\\\"IFCAIRTERMINALBOX\\\"] = 1096] = \\\"IFCAIRTERMINALBOX\\\";\\r\\n    ProductType[ProductType[\\\"IFCDAMPER\\\"] = 1148] = \\\"IFCDAMPER\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWMETER\\\"] = 1182] = \\\"IFCFLOWMETER\\\";\\r\\n    ProductType[ProductType[\\\"IFCVALVE\\\"] = 1311] = \\\"IFCVALVE\\\";\\r\\n    ProductType[ProductType[\\\"IFCELECTRICDISTRIBUTIONBOARD\\\"] = 1157] = \\\"IFCELECTRICDISTRIBUTIONBOARD\\\";\\r\\n    ProductType[ProductType[\\\"IFCELECTRICTIMECONTROL\\\"] = 1162] = \\\"IFCELECTRICTIMECONTROL\\\";\\r\\n    ProductType[ProductType[\\\"IFCPROTECTIVEDEVICE\\\"] = 1235] = \\\"IFCPROTECTIVEDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSWITCHINGDEVICE\\\"] = 1290] = \\\"IFCSWITCHINGDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWFITTING\\\"] = 467] = \\\"IFCFLOWFITTING\\\";\\r\\n    ProductType[ProductType[\\\"IFCDUCTFITTING\\\"] = 1153] = \\\"IFCDUCTFITTING\\\";\\r\\n    ProductType[ProductType[\\\"IFCPIPEFITTING\\\"] = 1222] = \\\"IFCPIPEFITTING\\\";\\r\\n    ProductType[ProductType[\\\"IFCCABLECARRIERFITTING\\\"] = 1111] = \\\"IFCCABLECARRIERFITTING\\\";\\r\\n    ProductType[ProductType[\\\"IFCCABLEFITTING\\\"] = 1113] = \\\"IFCCABLEFITTING\\\";\\r\\n    ProductType[ProductType[\\\"IFCJUNCTIONBOX\\\"] = 1195] = \\\"IFCJUNCTIONBOX\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWMOVINGDEVICE\\\"] = 502] = \\\"IFCFLOWMOVINGDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOMPRESSOR\\\"] = 1131] = \\\"IFCCOMPRESSOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCFAN\\\"] = 1177] = \\\"IFCFAN\\\";\\r\\n    ProductType[ProductType[\\\"IFCPUMP\\\"] = 1238] = \\\"IFCPUMP\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWSEGMENT\\\"] = 574] = \\\"IFCFLOWSEGMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCDUCTSEGMENT\\\"] = 1154] = \\\"IFCDUCTSEGMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCPIPESEGMENT\\\"] = 1223] = \\\"IFCPIPESEGMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCCABLECARRIERSEGMENT\\\"] = 1112] = \\\"IFCCABLECARRIERSEGMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCCABLESEGMENT\\\"] = 1115] = \\\"IFCCABLESEGMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWSTORAGEDEVICE\\\"] = 371] = \\\"IFCFLOWSTORAGEDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCTANK\\\"] = 1293] = \\\"IFCTANK\\\";\\r\\n    ProductType[ProductType[\\\"IFCELECTRICFLOWSTORAGEDEVICE\\\"] = 1159] = \\\"IFCELECTRICFLOWSTORAGEDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWTERMINAL\\\"] = 46] = \\\"IFCFLOWTERMINAL\\\";\\r\\n    ProductType[ProductType[\\\"IFCFIRESUPPRESSIONTERMINAL\\\"] = 1179] = \\\"IFCFIRESUPPRESSIONTERMINAL\\\";\\r\\n    ProductType[ProductType[\\\"IFCSANITARYTERMINAL\\\"] = 1262] = \\\"IFCSANITARYTERMINAL\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTACKTERMINAL\\\"] = 1277] = \\\"IFCSTACKTERMINAL\\\";\\r\\n    ProductType[ProductType[\\\"IFCWASTETERMINAL\\\"] = 1315] = \\\"IFCWASTETERMINAL\\\";\\r\\n    ProductType[ProductType[\\\"IFCAIRTERMINAL\\\"] = 1095] = \\\"IFCAIRTERMINAL\\\";\\r\\n    ProductType[ProductType[\\\"IFCMEDICALDEVICE\\\"] = 1212] = \\\"IFCMEDICALDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSPACEHEATER\\\"] = 1272] = \\\"IFCSPACEHEATER\\\";\\r\\n    ProductType[ProductType[\\\"IFCAUDIOVISUALAPPLIANCE\\\"] = 1099] = \\\"IFCAUDIOVISUALAPPLIANCE\\\";\\r\\n    ProductType[ProductType[\\\"IFCCOMMUNICATIONSAPPLIANCE\\\"] = 1127] = \\\"IFCCOMMUNICATIONSAPPLIANCE\\\";\\r\\n    ProductType[ProductType[\\\"IFCELECTRICAPPLIANCE\\\"] = 1156] = \\\"IFCELECTRICAPPLIANCE\\\";\\r\\n    ProductType[ProductType[\\\"IFCLAMP\\\"] = 1198] = \\\"IFCLAMP\\\";\\r\\n    ProductType[ProductType[\\\"IFCLIGHTFIXTURE\\\"] = 1199] = \\\"IFCLIGHTFIXTURE\\\";\\r\\n    ProductType[ProductType[\\\"IFCOUTLET\\\"] = 1219] = \\\"IFCOUTLET\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWTREATMENTDEVICE\\\"] = 425] = \\\"IFCFLOWTREATMENTDEVICE\\\";\\r\\n    ProductType[ProductType[\\\"IFCINTERCEPTOR\\\"] = 1193] = \\\"IFCINTERCEPTOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCDUCTSILENCER\\\"] = 1155] = \\\"IFCDUCTSILENCER\\\";\\r\\n    ProductType[ProductType[\\\"IFCFILTER\\\"] = 1178] = \\\"IFCFILTER\\\";\\r\\n    ProductType[ProductType[\\\"IFCDISTRIBUTIONCONTROLELEMENT\\\"] = 468] = \\\"IFCDISTRIBUTIONCONTROLELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCPROTECTIVEDEVICETRIPPINGUNIT\\\"] = 1236] = \\\"IFCPROTECTIVEDEVICETRIPPINGUNIT\\\";\\r\\n    ProductType[ProductType[\\\"IFCACTUATOR\\\"] = 1091] = \\\"IFCACTUATOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCALARM\\\"] = 1098] = \\\"IFCALARM\\\";\\r\\n    ProductType[ProductType[\\\"IFCCONTROLLER\\\"] = 1139] = \\\"IFCCONTROLLER\\\";\\r\\n    ProductType[ProductType[\\\"IFCFLOWINSTRUMENT\\\"] = 1181] = \\\"IFCFLOWINSTRUMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCSENSOR\\\"] = 1264] = \\\"IFCSENSOR\\\";\\r\\n    ProductType[ProductType[\\\"IFCUNITARYCONTROLELEMENT\\\"] = 1308] = \\\"IFCUNITARYCONTROLELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCCIVILELEMENT\\\"] = 1122] = \\\"IFCCIVILELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCELEMENTASSEMBLY\\\"] = 18] = \\\"IFCELEMENTASSEMBLY\\\";\\r\\n    ProductType[ProductType[\\\"IFCGEOGRAPHICELEMENT\\\"] = 1185] = \\\"IFCGEOGRAPHICELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCTRANSPORTELEMENT\\\"] = 416] = \\\"IFCTRANSPORTELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCVIRTUALELEMENT\\\"] = 168] = \\\"IFCVIRTUALELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALACTIVITY\\\"] = 41] = \\\"IFCSTRUCTURALACTIVITY\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALACTION\\\"] = 40] = \\\"IFCSTRUCTURALACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALCURVEACTION\\\"] = 1279] = \\\"IFCSTRUCTURALCURVEACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALLINEARACTION\\\"] = 463] = \\\"IFCSTRUCTURALLINEARACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALSURFACEACTION\\\"] = 1284] = \\\"IFCSTRUCTURALSURFACEACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALPLANARACTION\\\"] = 39] = \\\"IFCSTRUCTURALPLANARACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALPOINTACTION\\\"] = 356] = \\\"IFCSTRUCTURALPOINTACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALREACTION\\\"] = 355] = \\\"IFCSTRUCTURALREACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALCURVEREACTION\\\"] = 1280] = \\\"IFCSTRUCTURALCURVEREACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALPOINTREACTION\\\"] = 354] = \\\"IFCSTRUCTURALPOINTREACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALSURFACEREACTION\\\"] = 1285] = \\\"IFCSTRUCTURALSURFACEREACTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALITEM\\\"] = 226] = \\\"IFCSTRUCTURALITEM\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALCONNECTION\\\"] = 265] = \\\"IFCSTRUCTURALCONNECTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALCURVECONNECTION\\\"] = 534] = \\\"IFCSTRUCTURALCURVECONNECTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALPOINTCONNECTION\\\"] = 533] = \\\"IFCSTRUCTURALPOINTCONNECTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALSURFACECONNECTION\\\"] = 264] = \\\"IFCSTRUCTURALSURFACECONNECTION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALMEMBER\\\"] = 225] = \\\"IFCSTRUCTURALMEMBER\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALCURVEMEMBER\\\"] = 224] = \\\"IFCSTRUCTURALCURVEMEMBER\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALCURVEMEMBERVARYING\\\"] = 227] = \\\"IFCSTRUCTURALCURVEMEMBERVARYING\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALSURFACEMEMBER\\\"] = 420] = \\\"IFCSTRUCTURALSURFACEMEMBER\\\";\\r\\n    ProductType[ProductType[\\\"IFCSTRUCTURALSURFACEMEMBERVARYING\\\"] = 421] = \\\"IFCSTRUCTURALSURFACEMEMBERVARYING\\\";\\r\\n    ProductType[ProductType[\\\"IFCPORT\\\"] = 179] = \\\"IFCPORT\\\";\\r\\n    ProductType[ProductType[\\\"IFCDISTRIBUTIONPORT\\\"] = 178] = \\\"IFCDISTRIBUTIONPORT\\\";\\r\\n    ProductType[ProductType[\\\"IFCANNOTATION\\\"] = 634] = \\\"IFCANNOTATION\\\";\\r\\n    ProductType[ProductType[\\\"IFCSPATIALELEMENT\\\"] = 1273] = \\\"IFCSPATIALELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCSPATIALSTRUCTUREELEMENT\\\"] = 170] = \\\"IFCSPATIALSTRUCTUREELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCBUILDING\\\"] = 169] = \\\"IFCBUILDING\\\";\\r\\n    ProductType[ProductType[\\\"IFCBUILDINGSTOREY\\\"] = 459] = \\\"IFCBUILDINGSTOREY\\\";\\r\\n    ProductType[ProductType[\\\"IFCSITE\\\"] = 349] = \\\"IFCSITE\\\";\\r\\n    ProductType[ProductType[\\\"IFCSPACE\\\"] = 454] = \\\"IFCSPACE\\\";\\r\\n    ProductType[ProductType[\\\"IFCEXTERNALSPATIALSTRUCTUREELEMENT\\\"] = 1175] = \\\"IFCEXTERNALSPATIALSTRUCTUREELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCEXTERNALSPATIALELEMENT\\\"] = 1174] = \\\"IFCEXTERNALSPATIALELEMENT\\\";\\r\\n    ProductType[ProductType[\\\"IFCSPATIALZONE\\\"] = 1275] = \\\"IFCSPATIALZONE\\\";\\r\\n    ProductType[ProductType[\\\"IFCGRID\\\"] = 564] = \\\"IFCGRID\\\";\\r\\n    ProductType[ProductType[\\\"IFCPROXY\\\"] = 447] = \\\"IFCPROXY\\\";\\r\\n})(ProductType = exports.ProductType || (exports.ProductType = {}));\\r\\n\\n\\n//# sourceURL=webpack:///./src/product-type.ts?\");\n\n/***/ }),\n\n/***/ \"./src/state.ts\":\n/*!**********************!*\\n  !*** ./src/state.ts ***!\n  \**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/**\\r\\n    * Enumeration for object states.\\r\\n    * @readonly\\r\\n    * @enum {number}\\r\\n    */\\r\\nvar State;\\r\\n(function (State) {\\r\\n    State[State[\\\"UNDEFINED\\\"] = 255] = \\\"UNDEFINED\\\";\\r\\n    State[State[\\\"HIDDEN\\\"] = 254] = \\\"HIDDEN\\\";\\r\\n    State[State[\\\"HIGHLIGHTED\\\"] = 253] = \\\"HIGHLIGHTED\\\";\\r\\n    State[State[\\\"XRAYVISIBLE\\\"] = 252] = \\\"XRAYVISIBLE\\\";\\r\\n    State[State[\\\"PICKING_ONLY\\\"] = 251] = \\\"PICKING_ONLY\\\";\\r\\n    State[State[\\\"UNSTYLED\\\"] = 225] = \\\"UNSTYLED\\\";\\r\\n})(State = exports.State || (exports.State = {}));\\r\\n\\n\\n//# sourceURL=webpack:///./src/state.ts?\");\n\n/***/ }),\n\n/***/ \"./src/triangulated-shape.ts\":\n/*!***********************************!*\\n  !*** ./src/triangulated-shape.ts ***!\n  \***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar binary_reader_1 = __webpack_require__(/*! ./binary-reader */ \\\"./src/binary-reader.ts\\\");\\r\\nvar TriangulatedShape = /** @class */ (function () {\\r\\n    function TriangulatedShape() {\\r\\n        //This would load only shape data from binary file\\r\\n        this.load = function (source) {\\r\\n            //binary reading\\r\\n            var br = new binary_reader_1.BinaryReader();\\r\\n            var self = this;\\r\\n            br.onloaded = function () {\\r\\n                self.parse(br);\\r\\n                if (self.onloaded) {\\r\\n                    self.onloaded(this);\\r\\n                }\\r\\n            };\\r\\n            br.load(source, null);\\r\\n        };\\r\\n    }\\r\\n    //this will get xBinaryReader on the current position and will parse it's content to fill itself with vertices, normals and vertex indices\\r\\n    TriangulatedShape.prototype.parse = function (binReader) {\\r\\n        var self = this;\\r\\n        var version = binReader.readByte();\\r\\n        var numVertices = binReader.readInt32();\\r\\n        var numOfTriangles = binReader.readInt32();\\r\\n        self.vertices = binReader.readFloat32Array(numVertices * 3);\\r\\n        //allocate memory of defined size (to avoid reallocation of memory)\\r\\n        self.indices = new Uint32Array(numOfTriangles * 3);\\r\\n        self.normals = new Uint8Array(numOfTriangles * 6);\\r\\n        //indices for incremental adding of indices and normals\\r\\n        var iIndex = 0;\\r\\n        var readIndex;\\r\\n        if (numVertices <= 0xFF) {\\r\\n            readIndex = function (count) { return binReader.readByteArray(count); };\\r\\n        }\\r\\n        else if (numVertices <= 0xFFFF) {\\r\\n            readIndex = function (count) { return binReader.readUint16Array(count); };\\r\\n        }\\r\\n        else {\\r\\n            readIndex = function (count) { return binReader.readInt32Array(count); };\\r\\n        }\\r\\n        var numFaces = binReader.readInt32();\\r\\n        if (numVertices === 0 || numOfTriangles === 0)\\r\\n            return;\\r\\n        for (var i = 0; i < numFaces; i++) {\\r\\n            var numTrianglesInFace = binReader.readInt32();\\r\\n            if (numTrianglesInFace == 0)\\r\\n                continue;\\r\\n            var isPlanar = numTrianglesInFace > 0;\\r\\n            numTrianglesInFace = Math.abs(numTrianglesInFace);\\r\\n            if (isPlanar) {\\r\\n                var normal = binReader.readByteArray(2);\\r\\n                //read and set all indices\\r\\n                var planarIndices = readIndex(3 * numTrianglesInFace);\\r\\n                self.indices.set(planarIndices, iIndex);\\r\\n                for (var j = 0; j < numTrianglesInFace * 3; j++) {\\r\\n                    //add three identical normals because this is planar but needs to be expanded for WebGL\\r\\n                    self.normals[iIndex * 2] = normal[0];\\r\\n                    self.normals[iIndex * 2 + 1] = normal[1];\\r\\n                    iIndex++;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                for (var j = 0; j < numTrianglesInFace; j++) {\\r\\n                    self.indices[iIndex] = readIndex(); //a\\r\\n                    self.normals.set(binReader.readByteArray(2), iIndex * 2);\\r\\n                    iIndex++;\\r\\n                    self.indices[iIndex] = readIndex(); //b\\r\\n                    self.normals.set(binReader.readByteArray(2), iIndex * 2);\\r\\n                    iIndex++;\\r\\n                    self.indices[iIndex] = readIndex(); //c\\r\\n                    self.normals.set(binReader.readByteArray(2), iIndex * 2);\\r\\n                    iIndex++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n    return TriangulatedShape;\\r\\n}());\\r\\nexports.TriangulatedShape = TriangulatedShape;\\r\\n\\n\\n//# sourceURL=webpack:///./src/triangulated-shape.ts?\");\n\n/***/ }),\n\n/***/ \"./src/workers/geometry-loader.ts\":\n/*!****************************************!*\\n  !*** ./src/workers/geometry-loader.ts ***!\n  \****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar model_geometry_1 = __webpack_require__(/*! ../model-geometry */ \\\"./src/model-geometry.ts\\\");\\r\\n//only run following script if this is created as a Worker\\r\\nif (self && self instanceof DedicatedWorkerGlobalScope) {\\r\\n    var worker = self;\\r\\n    worker.onmessage = function (e) {\\r\\n        var model = e.data.model;\\r\\n        var headers = e.data.headers;\\r\\n        var geometry = new model_geometry_1.ModelGeometry();\\r\\n        geometry.onerror = function (msg) {\\r\\n            throw msg;\\r\\n        };\\r\\n        geometry.onloaded = function () {\\r\\n            try {\\r\\n                var msg = {};\\r\\n                var transferable = [];\\r\\n                for (var i in geometry) {\\r\\n                    if (!geometry.hasOwnProperty(i))\\r\\n                        continue;\\r\\n                    var prop = geometry[i];\\r\\n                    //ignore functions and private members when creating transferable message object\\r\\n                    if (typeof prop === \\\"function\\\" || i.startsWith(\\\"_\\\"))\\r\\n                        continue;\\r\\n                    //building message object containing values but no functions or anything\\r\\n                    msg[i] = prop;\\r\\n                    //create array of transferable objects for all typed arrays. Browsers which support Transferable interface will speed this up massively\\r\\n                    if (ArrayBuffer.isView(prop))\\r\\n                        transferable.push(prop.buffer);\\r\\n                }\\r\\n                //post the object and pass through all transferable objects\\r\\n                worker.postMessage(msg, transferable);\\r\\n                worker.close();\\r\\n            }\\r\\n            catch (e) {\\r\\n                worker.close();\\r\\n                throw e;\\r\\n            }\\r\\n        };\\r\\n        geometry.load(model, headers);\\r\\n    };\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./src/workers/geometry-loader.ts?\");\n\n/***/ })\n\n/******/ })));"